#!markdown

# Domin's Cookie Extractor

Use with `input.http` file as Cookies' source ([HTTP Request](https://developer.mozilla.org/en-US/docs/Web/HTTP/Messages#http_requests)),
<br/> or provide it within `__RAW_INPUT__` text string just below:

#!fsharp

let __INPUT_FILE__ = "input.http"
let __INPUT_FILE__FORCE__ = false

let __RAW_INPUT__ = """
# or provide It here
"""

#!fsharp

module InputFile =
    open System.IO

    let private whenPlausibleAsPath (path: string) =
        let invalidChars = Path.GetInvalidPathChars()
        let isInvalidChar ch =
            invalidChars |> Array.contains ch

        path.ToCharArray()
        |> Seq.where isInvalidChar
        |> Seq.isEmpty
        |> function
            | true -> Some path
            | _ -> None

    let private whenExistingFile (path: string) =
        let fullPath =
            if not <| Path.IsPathFullyQualified(path)
            then Path.GetFullPath(path)
            else path

        if File.Exists(fullPath)
        then Some fullPath
        else None


    let openTextFile path =
        match String.IsNullOrWhiteSpace(path) with
        | false -> path.Trim() |> Some
        | _ -> None
        |> Option.bind whenPlausibleAsPath
        |> Option.bind whenExistingFile
        |> Option.map File.OpenText

#!fsharp

module InputSource =
    open System.Text.RegularExpressions

    let private commentLinePattern =
        Regex @"^\s*#"

    let private readAllLines (source: TextReader) =
        let nextLine () = source.ReadLine()
        let isNotNull (x: string) =
            x |> (not << isNull)

        let mutable line = nextLine ()
        [ while line |> isNotNull do
            yield line
            line <- nextLine ()
        ]

    let private readFileLines path =
        let fromStream source =
            use stream = source
            stream |> readAllLines

        InputFile.openTextFile path
        |> Option.map fromStream

    let private splitToLines text =
        use stream = new StringReader(text)
        stream |> readAllLines

    let private withoutEmpty content =
        let notEmpty line =
            match line |> String.IsNullOrWhiteSpace with
            | false -> line.TrimEnd() |> Some
            | _ -> None

        let notComment line =
            commentLinePattern
                .IsMatch(line)
            |> not
            
        let lines =
            content
            |> Seq.choose notEmpty
            |> Seq.where notComment
            |> Seq.toList

        if not lines.IsEmpty
        then lines |> Some
        else None

    let getInputLines () =
        let readInputFileLines () =
            readFileLines __INPUT_FILE__
            |> Option.bind withoutEmpty

        let fromRawInputLines () =
            __RAW_INPUT__
            |> splitToLines
            |> withoutEmpty

        match __INPUT_FILE__FORCE__ with
        | true -> readInputFileLines ()
        | _ ->
            fromRawInputLines ()
            |> Option.orElseWith 
                readInputFileLines

#!fsharp

module HttpMessage =
    open System.Text.RegularExpressions

    let private whenLineMatch (pattern: Regex) line =
        let result = pattern.Match(line)
        match result.Success with
        | true -> result |> Some
        | _ -> None


    type Header = 
        { name: string
        ; value: string
        }

    module Header =
        let private pattern = 
            Regex @"^(?<Name>\w+): (?<Value>.*)$"

        let private toHeader (matched: Match) =
            let get (what: string) =
                matched.Groups[what].Value

            { name = get "Name"
            ; value = get "Value"
            }

        let parse line : Header option =
            line 
            |> whenLineMatch pattern
            |> Option.map toHeader

        let matches name (header: Header) =
            StringComparer.OrdinalIgnoreCase
                .Equals(name, header.name)
            |> function 
                | true -> header |> Some
                | _ -> None


    type Request =
        { lines: string list
        ; headers: Header list
        }

    module Request =
        let hasHeader name (request: Request) =
            request.headers
            |> Seq.choose 
                (Header.matches name)
            |> Seq.tryHead


module HttpMessages =
    open HttpMessage

    let parseRequest startLine request =
        let getHeaders = 
            Seq.choose Header.parse
            >> Seq.toList

        { lines = startLine :: request 
        ; headers = request |> getHeaders
        } |> Some

#!fsharp

module CookieSource =
    open System.Text.RegularExpressions
    open HttpMessage

    let private header = "Cookie"

    type Cookie =
        { key: string
        ; value: string
        }

    module Cookie =
        let private pattern =
            Regex @"(?<Key>.+)=(?<Value>.+)"

        let fromHeader (header: Header) =
            let toCookie value =
                let matched = pattern.Match(value)
                match matched.Success with
                | false -> 
                    $"Cannot parse %A{value} as Cookie entry"
                    |> failwith

                | true ->
                    let get (what: string) =
                        matched.Groups[what].Value

                    { key = get "Key"
                    ; value = get "Value"
                    }

            header.value.Split("; ")
            |> Seq.map toCookie
            |> Seq.toList


    let private asCookieHeader = function
        | [ line ] ->
            Header.parse line
            |> Option.bind
                (Header.matches header)

        | _ -> None

    let private asHttpRequest = function
        | startLine :: requestRest ->
            (startLine, requestRest)
            ||> HttpMessages.parseRequest
            |> Option.bind 
                (Request.hasHeader header)

        | [] -> None

    let private findCookies inputLines =
        [ asHttpRequest
        ; asCookieHeader
        ]
        |> Seq.choose ((|>) inputLines)
        |> Seq.tryHead
        |> Option.map 
            (Cookie.fromHeader)


    let get () =
        InputSource.getInputLines ()
        |> Option.bind findCookies
        |> (function
            | None -> Error "No-Input-Found"
            | Some value -> value |> Ok
        )


CookieSource.get ()
|> Result.map (List.skip 0 >> List.head)
|> function
    | Error er -> failwith er
    | Ok cookies -> cookies
