#!fsharp

let __certificate =
    {| dir = "certificates"
    ;  file = "domins.pfx"
    ;  secret = "minik"
    |}

#!markdown

### Generate Keys Pair and Certificate

Generate cert (pair of Keys):
* `openssl req -x509 -sha256 -nodes -days 365 -newkey rsa:4096 -keyout private.key -out certificates/domins.crt`

Verify created certificate:
* `openssl x509 -in certificates/domins.crt -text -noout`

Convert to Windows X509 format:
* `openssl pkcs12 -export -in certificates/domins.crt -inkey certificates/domins.private.key -out certificates/domins.pfx`

#!fsharp

module Certificate =
    open System.IO
    open System.Security
    open System.Security.Cryptography.X509Certificates


    let private certificateSecret =
        __certificate.secret

    let private certificateFilePath =
        [| __SOURCE_DIRECTORY__
        ;  __certificate.dir
        ;  __certificate.file
        |] |>  Path.Combine

    let private keyStorageFlags =
        X509KeyStorageFlags.DefaultKeySet


    let load () =
        if not (File.Exists(certificateFilePath)) then
            "Certificate file not found at:"
            + $"\n%s{certificateFilePath}"
            |> failwith

        new X509Certificate2
            ( certificateFilePath
            , certificateSecret
            , keyStorageFlags
            )


let certificate = Certificate.load ()
{| subject = certificate.Subject
;  thumbprint = certificate.Thumbprint
|}

#!markdown

### Check and Tests given Certificate

#!fsharp

let secret_message = """hit me with some enters ðŸ˜…"""

#!fsharp

module Cipher =
    open System.Text.Encodings
    open System.Security.Cryptography
    open System.Security.Cryptography.X509Certificates

    let encrypt (data: byte array): byte array =
        let padding = RSAEncryptionPadding.Pkcs1
        use rsa = certificate.GetRSAPublicKey()
        rsa.Encrypt(data, padding)

    let decrypt (data: byte array): byte array =
        let padding = RSAEncryptionPadding.Pkcs1
        use rsa = certificate.GetRSAPrivateKey()
        rsa.Decrypt(data, padding)

    let sign (data: byte array): byte array =
        let algorithm = HashAlgorithmName.MD5
        let padding = RSASignaturePadding.Pkcs1
        use rsa = certificate.GetRSAPrivateKey()
        rsa.SignData(data, algorithm, padding)

#!fsharp

module Client =
    let toBytes (text: string) =
        Encoding.UTF8.GetBytes(text)

    let toBase64 (bytes: byte array) =
        Convert.ToBase64String(bytes)

    let toString (bytes: byte array) =
        Encoding.UTF8.GetString(bytes)


    let private line = "-" |> String.replicate 6
    let private lineHead = line + line
    let private printLine (parts: string list) =
        String.concat " " parts
        |> printfn "%s"

    let printHeader message =
        [ lineHead; message; line ]
        |> printLine

    let printDetail message =
        [ line; message ]
        |> printLine


    let private lineOf (text: string) n =
        let limit = 80
        let idx = n * limit

        match idx < text.Length with
        | false -> None
        | _ ->
            match idx + limit < text.Length with
            | false -> text.Substring(idx)
            | _ -> text.Substring(idx, limit)
            |> Some

    let printBytes data =
        let content = data |> toBase64
        let lines =
            Seq.initInfinite (lineOf content)
            |> Seq.takeWhile Option.isSome
            |> Seq.map Option.get
            |> Seq.toList

        let toRowNumber n =
            Math.Log10(lines.Length)
            |> (int >> ((+) 1))
            |> sprintf "{0,%d}"
            |> fun f ->
                String.Format(f, n + 1)

        lines |> List.iteri (fun n line ->
            printfn $" {toRowNumber n} | {line}"
        )

        printfn ""


open Client

let raw = secret_message |> toBytes
printHeader "Raw Message"
printBytes raw

let cipher = raw |> Cipher.encrypt
printHeader "Encrypted"
printBytes cipher

let solution = cipher |> Cipher.decrypt
printHeader "Decrypted"
printBytes solution

let matched =
    let origin = raw |> Cipher.sign
    let found = solution |> Cipher.sign
    $"%A{origin = found}"

printHeader "Found Message"
printDetail $"Signatures Match: {matched}"
printfn $"%s{solution |> toString}"
